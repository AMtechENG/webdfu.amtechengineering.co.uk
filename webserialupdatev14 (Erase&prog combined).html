<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMtech Engineering PIC Firmware Update Interface</title>
    <style>
        body { font-family: sans-serif; background-color: #f4f4f4; color: #333; padding: 2em; }
        .container { max-width: 700px; margin: auto; background: white; padding: 2em; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1 { text-align: center; color: #005a9c; }
        button { background-color: #007bff; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; margin: 5px 0; }
        button:hover { background-color: #0056b3; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        input[type="file"] { margin: 10px 0; }
        input[type="text"] { padding: 8px; border-radius: 5px; border: 1px solid #ddd; width: calc(100% - 100px); }
        #log { background-color: #eee; border: 1px solid #ddd; padding: 10px; border-radius: 5px; margin-top: 1em; white-space: pre-wrap; font-family: monospace; max-height: 300px; overflow-y: auto; }
        .progress-bar { width: 100%; background-color: #e0e0e0; border-radius: 5px; margin: 10px 0; }
        .progress-bar-fill { height: 24px; width: 0%; background-color: #4caf50; border-radius: 5px; text-align: center; line-height: 24px; color: white; }
        .debug-message { color: #888; } /* Gray color for debug messages */
    </style>
</head>
<body>

<div class="container">
    <h1>AMtech Engineering DFU Interface</h1>
    <p>Click "Connect" to find your device and verify communication.</p>

    <button id="connectButton">1. Connect to Device & Verify</button>
    <div id="deviceInfo" style="margin-top: 10px;">Status: Disconnected</div>

    <hr>

    <label for="fileInput">2. Select Firmware (.hex) File:</label>
    <input type="file" id="fileInput" accept=".hex" disabled>

    <hr>
    
    <button id="programButton" disabled>3. Erase & Program Device</button>
    
    <div class="progress-bar">
        <div id="progressBar" class="progress-bar-fill">0%</div>
    </div>
    
    <hr>

    <h3>Manual Command Interface</h3>
    <label for="manualCommandInput">Command (hex bytes):</label>
    <input type="text" id="manualCommandInput" placeholder="e.g., 03 23 00 55..." disabled>
    <button id="sendManualCommandButton" disabled>Send</button>

    <h3>Log:</h3>
    <pre id="log">Awaiting connection...</pre>
</div>

<script>
    const CMD = {
        READ_VERSION:              0x00,
        WRITE_FLASH:               0x02,
        ERASE_FLASH:               0x03,
        GET_MEMORY_ADDRESS_RANGE:  0x0B,
        RESET_DEVICE:              0x09
    };
    const UNLOCK_SEQUENCE = 0x00AA0055;
    const COMMAND_HEADER_SIZE = 11;
    const USB_PACKET_SIZE = 64;

    const PIC24_VENDOR_ID = 0x04D8;
    const PIC24_PRODUCT_ID = 0x000A;
    
    let APP_START_ADDRESS = 0;
    let APP_END_ADDRESS = 0;
    let ERASE_PAGE_SIZE = 2048; // Default, will be updated from device

    const connectButton = document.getElementById('connectButton');
    const fileInput = document.getElementById('fileInput');
    const programButton = document.getElementById('programButton');
    const deviceInfo = document.getElementById('deviceInfo');
    const logElement = document.getElementById('log');
    const progressBar = document.getElementById('progressBar');
    const manualCommandInput = document.getElementById('manualCommandInput');
    const sendManualCommandButton = document.getElementById('sendManualCommandButton');


    let device = null;
    let firmwareData = null;
    let cdcInterfaceNumber = -1;
    let writeEndpointNumber = -1;
    let readEndpointNumber = -1;

    connectButton.addEventListener('click', () => device ? disconnectDevice() : connectDevice());
    fileInput.addEventListener('change', handleFileSelect);
    programButton.addEventListener('click', programDevice);
    sendManualCommandButton.addEventListener('click', sendManualCommand);


    function log(message, isDebug = false) {
        console.log(message);
        const span = document.createElement('span');
        if (isDebug) {
            span.className = 'debug-message';
        }
        span.textContent = message + '\n';
        logElement.appendChild(span);
        logElement.scrollTop = logElement.scrollHeight;
    }
    
    function debugLog(message) {
        log(`[DEBUG] ${message}`, true);
    }

    function logBytes(prefix, dataView) {
        const bytes = Array.from({ length: dataView.byteLength }, (_, i) => dataView.getUint8(i).toString(16).padStart(2, '0'));
        debugLog(`${prefix} [${bytes.join(' ')}]`);
    }

    function withTimeout(promise, ms, errorMsg) {
        return new Promise((resolve, reject) => {
            const timer = setTimeout(() => reject(new Error(errorMsg)), ms);
            promise.then(
                value => { clearTimeout(timer); resolve(value); },
                error => { clearTimeout(timer); reject(error); }
            );
        });
    }

    function updateProgress(percentage) {
        progressBar.style.width = `${percentage}%`;
        progressBar.textContent = `${Math.round(percentage)}%`;
    }
    
    function getUint24(dataView, offset) {
        const byte1 = dataView.getUint8(offset);
        const byte2 = dataView.getUint8(offset + 1);
        const byte3 = dataView.getUint8(offset + 2);
        return byte1 | (byte2 << 8) | (byte3 << 16);
    }

    async function connectDevice() {
        if (!navigator.usb) {
            log('Error: WebUSB is not supported. Please use Chrome or Edge.');
            return;
        }
        
        connectButton.disabled = true;

        try {
            log('Requesting USB device...');
            device = await navigator.usb.requestDevice({ filters: [{ vendorId: PIC24_VENDOR_ID, productId: PIC24_PRODUCT_ID }] });
            log(`Device selected: ${device.manufacturerName} ${device.productName}`);
            
            await device.open();
            await device.selectConfiguration(1);
            
            for (const iface of device.configuration.interfaces) {
                for (const alt of iface.alternates) {
                    if (alt.interfaceClass === 0x0A) { // CDC-Data
                        cdcInterfaceNumber = iface.interfaceNumber;
                        alt.endpoints.forEach(ep => {
                            if (ep.direction === 'out') writeEndpointNumber = ep.endpointNumber;
                            else if (ep.direction === 'in') readEndpointNumber = ep.endpointNumber;
                        });
                        break; 
                    }
                }
                 if (cdcInterfaceNumber !== -1) break;
            }

            if (cdcInterfaceNumber === -1) throw new Error("Could not find CDC-Data interface.");
            
            await device.claimInterface(cdcInterfaceNumber);
            log(`Interface ${cdcInterfaceNumber} claimed. Endpoints: IN=${readEndpointNumber}, OUT=${writeEndpointNumber}`);
            
            deviceInfo.textContent = `Status: Connected to ${device.productName}`;
            fileInput.disabled = false;
            manualCommandInput.disabled = false;
            sendManualCommandButton.disabled = false;
            connectButton.textContent = 'Disconnect';

            // Fetch device info after connecting
            await new Promise(resolve => setTimeout(resolve, 1000));
            const versionResponse = await sendCommand(CMD.READ_VERSION, 0, 0, 0);
            const responseView = versionResponse.data;
            ERASE_PAGE_SIZE = responseView.getUint16(21, true);
            const memRangeResponse = await sendCommand(CMD.GET_MEMORY_ADDRESS_RANGE, 8, 0, 0);
            APP_START_ADDRESS = getUint24(memRangeResponse.data, 12);
            APP_END_ADDRESS = getUint24(memRangeResponse.data, 16);
            log(`Device reports programmable memory: 0x${APP_START_ADDRESS.toString(16)} to 0x${APP_END_ADDRESS.toString(16)}`);

        } catch (error) {
            log(`Error: ${error.message}`);
            if (device) await device.close().catch(()=>{});
            device = null;
        } finally {
            connectButton.disabled = false;
        }
    }
    
    async function disconnectDevice() {
        if (!device) return;
        try {
            await device.releaseInterface(cdcInterfaceNumber);
            await device.close();
            log('Device disconnected.');
        } catch (error) {
            log(`Disconnect Error: ${error.message}`);
        }
        device = null;
        deviceInfo.textContent = 'Status: Disconnected';
        fileInput.disabled = true;
        programButton.disabled = true;
        manualCommandInput.disabled = true;
        sendManualCommandButton.disabled = true;
        connectButton.textContent = '1. Connect to Device & Verify';
        connectButton.disabled = false;
    }
    
    function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                firmwareData = parseHexFile(e.target.result);
                log(`Firmware loaded: ${firmwareData.length} data records found.`);
                programButton.disabled = false;
            } catch (err) {
                log(`Error parsing HEX file: ${err.message}`);
                firmwareData = null;
                programButton.disabled = true;
            }
        };
        reader.readAsText(file);
    }

    async function programDevice() {
        if (!device || !firmwareData) {
            log('Error: Device not connected or no firmware loaded.');
            return;
        }
        
        [programButton, fileInput, connectButton].forEach(el => el.disabled = true);
        
        try {
            // --- ERASE PHASE ---
            log('--- Starting Erase ---');
            updateProgress(0);
            const numPages = Math.ceil((APP_END_ADDRESS - APP_START_ADDRESS) / ERASE_PAGE_SIZE);
            log(`Erasing ${numPages} pages...`);
            await sendCommand(CMD.ERASE_FLASH, numPages, APP_START_ADDRESS, UNLOCK_SEQUENCE, null, 15000);
            log('--- Erase Successful ---');
            updateProgress(10);

            // --- PROGRAM PHASE ---
            log('--- Starting Firmware Write ---');
            const appStartByteAddress = APP_START_ADDRESS * 2;
            const appEndByteAddress = APP_END_ADDRESS * 2;
            
            let appRecords = firmwareData.filter(r => r.address >= appStartByteAddress && r.address <= appEndByteAddress);
            if (appRecords.length === 0) {
                throw new Error(`Invalid HEX file. No data found in the device's programmable range.`);
            }
            let endAddress = appRecords.reduce((max, r) => Math.max(max, r.address + r.data.length), 0);

            const WRITE_CHUNK_SIZE = 32;
            const fullFirmwareImage = new Uint8Array(endAddress - appStartByteAddress).fill(0xFF);
            for(const record of appRecords) {
                if(record.address >= appStartByteAddress) {
                    fullFirmwareImage.set(record.data, record.address - appStartByteAddress);
                }
            }
            const paddedSize = Math.ceil(fullFirmwareImage.length / WRITE_CHUNK_SIZE) * WRITE_CHUNK_SIZE;
            const paddedFirmwareImage = new Uint8Array(paddedSize).fill(0xFF);
            paddedFirmwareImage.set(fullFirmwareImage);

            let totalBytesWritten = 0;
            const totalBytesToWrite = paddedFirmwareImage.length;
            
            for(let byteOffset = 0; byteOffset < totalBytesToWrite; byteOffset += WRITE_CHUNK_SIZE) {
                const chunk = paddedFirmwareImage.slice(byteOffset, byteOffset + WRITE_CHUNK_SIZE);
                const currentWordAddress = APP_START_ADDRESS + (byteOffset / 2);
                
                await sendCommand(CMD.WRITE_FLASH, chunk.length, currentWordAddress, UNLOCK_SEQUENCE, chunk);
                
                totalBytesWritten += chunk.length;
                updateProgress(10 + (totalBytesWritten / totalBytesToWrite) * 85);
            }
            log('--- Write Successful ---');
            updateProgress(95);
            
            // --- RESET PHASE ---
            log('Resetting device...');
            await sendCommand(CMD.RESET_DEVICE, 0, 0, UNLOCK_SEQUENCE);
            updateProgress(100);
            log('--- Firmware Update Complete! ---');
            await disconnectDevice();

        } catch (error) {
            log(`Update process failed: ${error.message}`);
            // Re-enable controls on failure
            [programButton, fileInput, connectButton].forEach(el => el.disabled = false);
            if(!firmwareData) { programButton.disabled = true; }
        }
    }

    async function sendManualCommand() {
        if (!device) {
            log("Error: Device not connected.");
            return;
        }
        sendManualCommandButton.disabled = true;
        try {
            const commandString = manualCommandInput.value;
            const bytes = commandString.trim().split(/[\s,]+/).map(hex => parseInt(hex, 16));
            
            if (bytes.some(isNaN)) {
                log("Error: Invalid hex value in command string.");
                return;
            }
            
            const packet = new Uint8Array(USB_PACKET_SIZE).fill(0);
            packet.set(bytes);

            log(`Sending manual command...`);
            logBytes(`Manual Packet:`, new DataView(packet.buffer));
            await device.transferOut(writeEndpointNumber, packet);
            

            // Listen for the reply
            const readPromise = device.transferIn(readEndpointNumber, USB_PACKET_SIZE);
            const result = await withTimeout(readPromise, 2000, 'Timeout: No response from device for manual command.');

            if (result.status !== 'ok') {
                throw new Error(`USB transfer IN failed with status: ${result.status}`);
            }
            
            // Log the full reply
            logBytes(`Received Manual Response:`, result.data);

        } catch (error) {
            log(`Manual command failed: ${error.message}`);
        } finally {
            sendManualCommandButton.disabled = false;
        }
    }
    
    async function sendCommand(command, length, address, unlockKey, data = null, timeout = 2000) {
        const packet = new Uint8Array(USB_PACKET_SIZE);
        const view = new DataView(packet.buffer);
        
        view.setUint8(0, command);
        view.setUint16(1, length, true);
        view.setUint32(3, unlockKey, true);
        view.setUint32(7, address, true);

        if (data) {
            packet.set(data, COMMAND_HEADER_SIZE);
        }
        
        let logPrefix = `Sending Packet (CMD: 0x${command.toString(16).padStart(2,'0')})`;
        if (command === CMD.WRITE_FLASH) {
            logPrefix += ` Device address: 0x${address.toString(16)}`;
        }
        logPrefix += '):';
        logBytes(logPrefix, new DataView(packet.buffer));
        
        const writePromise = device.transferOut(writeEndpointNumber, packet);
        await withTimeout(writePromise, timeout, 'Timeout: USB write operation failed to complete.');
        
        if (command === CMD.RESET_DEVICE) {
            log('Reset command sent. No response expected.');
            return null;
        }


        const readPromise = device.transferIn(readEndpointNumber, USB_PACKET_SIZE);
        const result = await withTimeout(readPromise, timeout, `Timeout: No response from device for command 0x${command.toString(16)}.`);

        if (result.status !== 'ok') throw new Error(`USB transfer IN failed with status: ${result.status}`);
        
        const logPrefixReceived = (command === CMD.READ_VERSION || command === CMD.GET_MEMORY_ADDRESS_RANGE) ? "Received Data:" : "Received ACK/NAK:";
        logBytes(logPrefixReceived, result.data);

        if (command === CMD.READ_VERSION || command === CMD.GET_MEMORY_ADDRESS_RANGE) {
            const responseCmd = result.data.getUint8(0);
             if (responseCmd !== command) {
                throw new Error(`Command mismatch. Sent 0x${command.toString(16)}, received response for 0x${responseCmd.toString(16)}`);
            }
            return result;
        }

        const responseCmd = result.data.getUint8(0);
        const success = result.data.getUint8(11);
        
        if (responseCmd !== command) {
             throw new Error(`Command mismatch. Sent 0x${command.toString(16)}, received response for 0x${responseCmd.toString(16)}`);
        }
        if (success !== 1) { 
             throw new Error(`Command 0x${command.toString(16)} failed with device response code: 0x${success.toString(16)}`);
        }
        return result;
    }

    function parseHexFile(hexString) {
        const records = [];
        let extendedLinearAddress = 0;
        hexString.split(/\r?\n/).forEach(line => {
            if (line.startsWith(':') && line.length >= 11) {
                const byteCount = parseInt(line.substring(1, 3), 16);
                const address = parseInt(line.substring(3, 7), 16);
                const recordType = parseInt(line.substring(7, 9), 16);
                if (line.length < 11 + byteCount * 2) return;
                const dataBytes = Array.from({ length: byteCount }, (_, i) => parseInt(line.substring(9 + i * 2, 11 + i * 2), 16));

                if (recordType === 0x00) { // Data Record
                    records.push({ address: (extendedLinearAddress << 16) | address, data: new Uint8Array(dataBytes) });
                } else if (recordType === 0x04) { // Extended Linear Address Record
                    extendedLinearAddress = (dataBytes[0] << 8) | dataBytes[1];
                }
            }
        });
        return records.sort((a, b) => a.address - b.address);
    }
</script>

</body>
</html>